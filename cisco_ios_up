#!/usr/bin/perl 

use strict;
use Expect;
use Getopt::Long;


my %defaults;
$defaults{server} = "%%YOURFTPSERVER%%";
$defaults{proto} = "tftp";
$defaults{verify} = 1;
$defaults{delete} = 1;
$defaults{squeeze} = 0;
$defaults{ftpuser} = "%%YOURFTPUSERNAMEHERE%%";
$defaults{ftppass} = "%%YOURFTPPASSWORDHERE%%";
$defaults{dir} = "IOS";
$defaults{device} = "flash";
$defaults{logincmd} = "clogin";
my %config;

# interactive mode should prompt if they want to change the model profile,
# change that routers profile, or just use the settings this one time.
GetOptions (
    "interactive+"          => \$config{interactive},
    "delete+"               => \$config{delete},
    "server|tftpsrv=s"      => \$config{server}, 
    "dir=s"                 => \$config{dir},     
    "protocol=s"            => \$config{proto},
    "code=s"                => \$config{code}, 
    "verify+"               => \$config{verify},
    "device=s"              => \$config{device},
    "archive+"              => \$config{archive},
    "squeeze+"              => \$config{squeeze},
    "ftpuser=s"             => \$config{ftpuser},
    "ftppass=s"             => \$config{ftppass},
    "force+"                => \$config{force},
);  

$Expect::Log_Stdout=1;

# this should be in a config file
my @codes = (

    { "26(2|1)[0-1]\$" => { code => "", dir => "IOS/2600", flashsize => "16384" } },
    { "26(5|2|1)[0-1]XM\$" => { code => "", dir => "IOS/2600", flashsize => "32768", squeeze => 1 } },
    { "uBR711[14]" => { code => "", dir => "IOS/ubr7100", device => "disk0" } },
    { "uBR7246VXR" => { code => "", dir => "IOS/ubr7200", device => "disk2", proc => "UBR7200-NPE-G1",
                        bootflash => "", bootdev => "bootflash" } },
    { "uBR72(23|46)" => { code => "", dir => "IOS/ubr7200", device => "disk1", 
                        bootflash => "", bootdev => "slot0" } },
    { "AIR-AP123(1G|2AG|0B)-A-K9" => { code => "", dir => "IOS/1200", archive => "" } },
    { "AIR-AP1220-IOS-UPGRD" => { code => "", dir => "IOS/1200", archive => 1 } },
    { "2811" => { code => "", dir => "IOS/2800" } },
    { "7120-(T3|4T1)" => { code => "", dir => "IOS/7100" } },
    { "WS-C650[369].*" => { code => "", device => "disk0" } },
    { "ME-2400.*" => { code => "", dir => "IOS/ME2400" } },
    { "ME-3400.*" => { code => "", dir => "IOS/ME3400" } },
    { "ME-C6524GT-8S" => { code => "", dir => "IOS/ME6500" } },
    { "WS-C3750.*" => { code => "", dir => "IOS/3750" } },
    { "WS-C2960-.*" => { code => "", dir=> "IOS/2960", archive => "1" } },
    { "WS-C3550-12G" => { code => "", dir=> "IOS/3550" } },
    { "WS-C29(50|50G|50T)-.*" => { code => "", dir=> "IOS/2950" } },
    { "WS-C29(40)-.*" => { code => "", dir=> "IOS/2940" } },
    { "371098-001" => { code => "", dir => "IOS/GESM", archive=> "1" } },
    { "WS-CBS3020-HPQ" => { code => "", dir => "IOS/GESM", archive=> "1" } },
    { "WS-C3560-48PS" => { code => "", dir=> "IOS/3560" } },
    { "3745" => { code => "", dir => "IOS/3745", device => "flash" } },
    { "1841" => { code => "", dir => "IOS/1800" } },
    { "7120-T3" => { code => "", dir => "IOS/7100", device => "disk0" } },
    # deleting files might be a problem here, the gre-56-mar DPCA stuff takes
    # up about 20 files
    { "7401ASR" => { code => "", dir => "IOS/7400", device => "disk0" } },
    { "IAD2420" => { code => "", dir => "IOS/IAD2420" } },
    { "IAD2430" => { code => "", dir => "IOS/IAD2430", device => "slot0" } },
    { "IAD2432" => { code => "", dir => "IOS/IAD2430", device => "flash" } },
    { "VG224" => { code => "", dir => "IOS/VG224", device => "slot0" } },
    { "WS-C3524-(PWR-)?XL" => { code => "", dir => "IOS/3500XL", no_recursive => "1" } },
    { "WS-C29(24|12).?-XL" => { code => "", dir => "IOS/2900XL", no_recursive => "1" } },
    { "WS-C3550-48" => { code => "", dir => "IOS/c3550" } },
);

my %protected_files = ( "config.txt" => 1, "private-config" => 1, "private-config.text" => 1,
                        "multiple-fs" => 1, "config.text" => 1, "vlan.dat" => 1, "root-cert" => 1);


my $exp = new Expect;

sub find_type {
    my $t = shift;
    my $proc = shift;
    for(@codes) {
        my ($type) = keys(%$_);
        my $value = $_->{$type};
        next if (defined($proc) && defined($value->{proc}) && ($proc ne $value->{proc}));
        return $value if ($t =~ $type);
    }
}

sub send_verify {
    my $verify = shift;
    my $image = shift;
    return if (!$verify);
    $exp->send("verify $image\r");                              
    $exp->expect(30,
             [ qr/\./ => sub { exp_continue; } ],
             [ qr/#/ => sub { } ],
             [ timeout => sub { die "*** TIMEOUT in VERIFY\n"; } ]);
}

sub wait_for_download {
    $exp->expect(600,
        [ qr/Erase (slot\d+|flash): before copying\? \[confirm\]/ => sub { $exp->send("n"); exp_continue } ],
        [ qr/Destination filename/ => sub { $exp->send("\r"); exp_continue } ],
        [ qr/Accessing|\!|extracting.*/ => sub { exp_continue } ],
        [ qr/#/ => sub { } ],
        [ timeout => sub { die "*** TIMEOUT while TFTP\n"; } ]);
}


sub get_version {
    my ($ver,$type,$flashsize,$proc);
    my $type = "unknown";
    my $ver = "unknown";

    $exp->send("sh ver\r");

    # since we didn't pass $host our failures can't include it.  We might want
    # to figure out how to soft-fail here and pass that back to the main code
    # to have it hard failure.
    $exp->expect(100,
           [ qr/System image file is "(\S+)"/ => sub { $ver = ($exp->matchlist)[0]; exp_continue; } ],
           [ qr/[Cc]isco (\S+)\s+\((.*?)\).*?with \d+K/ => sub { $proc = ($exp->matchlist)[1]; $type = ($exp->matchlist)[0]; exp_continue; } ],
           [ qr/Running default software/ => sub { } ],
           [ qr/(\S+)K bytes of processor board System flash \(Read\/Write\)/ 
                => sub { $flashsize = ($exp->matchlist)[0]; exp_continue; } ],
           [ "Configuration register" => sub { if ($type eq "unknown" || $ver eq "unknown") { exp_continue; } } ],
           [ timeout => sub { die "*** Timed out processing sh ver\n"; } ],
           [ eof => sub { die "Unexpected eof\n"; } ],
    );

    return ($ver, $type, $proc, $flashsize);
}

# because this is recursive and returns arrays it has to be evaluated and
# "die" when something goes wrong (or you accept death as the consequences of
# failure)
sub remote_dir {
    my $target = shift;
    my $ios = shift;
    my $norecursive = shift;
    my $path = $target;
    # strip device name from the path
    $path =~ s/^\S+://;
    my @files;
    my @dirs;

    die if (!defined($ios));

    # needed to make sure the previous remote_dir command doesn't cause this
    # one to match '#' or something.
    $exp->clear_accum();
    $exp->send("dir $target\r");
    $exp->expect(100,
            # matching flags, date or <no date>, time offset or space, filename
            [ qr/\s+\d+\s+(\S{4})\s+\d+\s+(\w{3}\s+\d+\s+\d{4}\s+\d+:\d+:\d+|<no date>)(\s+[\+\-]\d+:\d+\s+|\s+)(\S+)/ => 
                sub {   my $file = ($exp->matchlist)[3];
                        my $flags = ($exp->matchlist)[0];
                        if ($file eq $ios && !$config{force}) {
                            print "Staged version current.\n";
                            die;
                        }
                        if ($flags =~ /^d/ && $norecursive) {
                            push(@dirs, "$target/$file/");
                        } else {
                            push(@files, "$path$file"); 
                        }
                        exp_continue; 
                    }
            ],
            [ qr/#/ => sub { } ],
            [ timeout => sub { die "*** Timeout at dir $target\n"; } ] 
    );

    # this has to happen after the current directory parsing is complete
    for(@dirs) {
        push(@files, remote_dir($_, $ios, $norecursive));
    }

    return @files;

}

sub delete_files {
    my $device = shift;
    my $norecursive = shift;
    my @files = @_;

    for (@files) {
        next if ($protected_files{$_});
        if (!$norecursive) {
            $exp->send("delete /recursive /force $device:$_\r");
        } else {
            $exp->send("delete $device:$_\r");
        }
        $exp->expect(100,
            [ qr/Examine files in directory/ => sub { $exp->send("y"); exp_continue } ],
            [ qr/Delete filename/ => sub { $exp->send("\r"); exp_continue } ],
            [ qr/Delete.*\[confirm\]/ => sub { $exp->send("y"); exp_continue } ],
            [ qr/#/ => sub { } ],
            [ timeout => sub { die "*** Timeout at delete file\n"; } ] );
    }
}

sub squeeze {

    my $device = shift;

    $exp->send("squeeze $device:\r");
    $exp->expect(100,
        [ qr/All deleted files will be removed. Continue\? \[confirm\]/ => sub { $exp->send("y"); exp_continue } ],
        [ qr/Squeeze operation may take a while. Continue\? \[confirm\]/ => sub { $exp->send("y"); exp_continue } ],
        [ qr/#/ => sub { } ],
        [ timeout => sub { die "*** Timeout at delete file\n"; } ] );

}



HOST: for (@ARGV) {
    my $host = $_;
    my $prompt = "";
    $exp->soft_close() if ($exp->pid());
    $exp = Expect->spawn("$defaults{logincmd} $host");
    $exp->expect(15, 
           [ qr/(\S+)#/ => sub { $prompt = ($exp->matchlist)[0]; } ],
           [ timeout => sub { die "*** Timed out in Connecting to $host\n"; } ]);

    $exp->send("term len 0\r");

    my ($ver, $type, $proc, $flashsize) = get_version();

    my %values = %defaults;

    my $model = find_type($type, $proc);
    if (defined($model)) {
        # add things from the determined model, these have middle priority
        @values{ keys %$model } = values %$model;
    }
   
    # add things from the CLI, these have highest priority.  Don't overwrite
    # if value=undef
    foreach my $key ( keys %config ) {
        next if (!defined($config{$key}));
        $values{$key}=$config{$key};
    }

    my $ios = $values{code};
    my $archive  = $values{archive};
    my $dir = $values{dir};
    my $device = $values{device};
    my $squeeze = $values{squeeze};
    my $srv = $values{server};
    my $ftpuser = $values{ftpuser};
    my $ftppass = $values{ftppass};
    my $proto = $values{proto};
    my $bootflash = $values{bootflash};
    my $bootdev = $values{bootdev};

    my $user = "";
    if ($proto eq "ftp") {
        $user = "$ftpuser:$ftppass\@";
    }

    if (!defined($ios)) {
        print "Unknown device type $type.  No IOS available\n";
        $exp->send("exit\r");
        $exp->soft_close();
        next HOST;
    }

    if (defined($values{flashsize}) && $flashsize < $values{flashsize}) {
        my $needed = $values{flashsize};
        print "Flash isn't large enough to support code ($flashsize < $needed)\n";
        exit;
    }


    # get rid of everything prior to the last /
    $ver =~ s/(flash|slot0|disk[0-9])://;
    $ver =~ s#.*/(\S+)#$1#;

    $exp->expect(100, '-re', '#');

    my @files;
    if (($ver eq $ios || ($archive && $ver eq $archive)) && !$values{force}) {
        print "Version already current.\n";
    } else {
        eval { @files = remote_dir("$device:", $ios, $values{no_recursive}) };

        if (!($@)) {
            if ($archive) {
                $exp->send("archive download-sw /overwrite $proto://$user$srv/$dir/$ios\r");
                wait_for_download();
            } else {
                delete_files($device, $values{no_recursive}, @files) if ($values{delete});
                squeeze($device) if ($squeeze);
                
                $exp->send("copy $proto://$user$srv/$dir/$ios $device:\r");
                wait_for_download();
                send_verify($values{verify}, "$device:$ios");
            }
        }
    }

    my @bootfiles;
    eval { @bootfiles = remote_dir("$bootdev:", $bootflash, $values{no_recursive}); };
    if (!($@)) {
        delete_files($bootdev, $values{no_recursive}, @bootfiles) if ($values{delete});
        squeeze($bootdev) if ($squeeze);

        $exp->send("copy $proto://$user$srv/$dir/$bootflash $bootdev:\r");
        wait_for_download();
        send_verify($values{verify}, "$device:$bootflash");
    }

    $exp->send("reload\ry") if ($values{reload});
    $exp->send("exit\r");
    $exp->soft_close();
}

